---
title: Yarn, un n-iÃ¨me package-manager ?
date: "2016-11-10T12:00:00.000Z"
description: Quâ€™est-ce que se cache vraiment derriÃ¨re ce n-iÃ¨me package-manager, annoncÃ© il y a quelques semaines par Facebook
template: "post"
draft: false
slug: "yarn"
category: "Dev"
language: ğŸ‡«ğŸ‡·
tags:
  - "JS"
socialImage: "/d3rwan-blog/media/yarn/logo.jpeg"
---

Npm, Bower, JSPMâ€¦ A chaque saison son nouveau package-manager dans lâ€™Ã©cosystÃ¨me JS. Le dernier nÃ©, Yarn, a Ã©tÃ© annoncÃ© il y a quelques semaines par les dÃ©velopppeurs de Facebook. Alors, quâ€™est-ce que se cache vraiment derriÃ¨re ce n-iÃ¨me package-manager ?

[Yarn: A new package manager for JavaScript](https://code.facebook.com/posts/1840075619545360)

En premier lieu, Yarn nâ€™a pas lâ€™objectif de remplacer npm ou bower. Il sâ€™agit avant-tout dâ€™un nouveau client ligne de commande permettant la rÃ©cupÃ©ration de dÃ©pendances depuis le registry npm.

Il propose en outre les amÃ©liorations suivantes :

* **Performance**
Optimisation des appels et maximisation de lâ€™utilisation rÃ©seau, notamment via un mÃ©canisme dâ€™analyse de lâ€™arbre des dÃ©pendances et de parallÃ©lisation des requÃªtes (vs. en sÃ©rie pour npm)

* **DÃ©terministe**
Pour un mÃªme projet, les mÃªmes dÃ©pendances seront installÃ©es de la mÃªme maniÃ¨re sur tous les environnements (plus dâ€™effet *â€œ it works on my machineâ€*)

* **Fonctionnement offline**
Une fois un package installÃ©, il est mis en cache et pourra Ãªtre installÃ© ensuite sans connexion internet

* **RÃ©silience** 
Le processus dâ€™installation est plus robuste, notamment dans le cas de coupure rÃ©seau (rejeu des requÃªtes vs. processus dâ€™installation en erreur)

* **Registre multiple**
PossibilitÃ© de rÃ©cupÃ©rer des sources depuis plusieurs registres (npm, bower, github, â€¦)

* **SÃ©curitÃ©**
Utilisation de checksums pour vÃ©rifier lâ€™intÃ©gritÃ© des dÃ©pendances

## Mise en place

Pour installer Yarn, le plus simple est encore dâ€™utiliserâ€¦ npm.

    npm install -g yarn

DÃ¨s lors, on peut utiliser le client yarn en lieu et place du client npm

    # npm install
    yarn

    # npm init
    yarn init

    # npm install angular --save
    yarn add angular 

    # npm install gulp --global
    yarn global agg gulp

    # npm uninstall angular --save
    yarn remove angular

    # npm install angular-mocks --save-dev
    yarn add angular-mocks --dev

![Installation avec Yarn](/media/yarn/yarn_loading.gif)*Installation avec Yarn*

Pour le reste, on continue dâ€™utiliser le fichier *package.json* pour lister les dÃ©pendances dâ€™un projet, dÃ©pendances qui seront toujours stockÃ©es dans le rÃ©pertoire *node_modules*. Yarn ajoute nÃ©anmoins un nouveau fichier *yarn.lock*. Câ€™est ce fichier qui va garantir lâ€™installation dÃ©terministe, puisquâ€™il va lister chaque dÃ©pendance, la version exacte Ã  utiliser, lâ€™ordre dâ€™installation etcâ€¦ Ce fichier sera crÃ©e lors de la premiÃ¨re installation par Yarn, puis mis Ã  jour ensuite lors de chaque modification.

Il est important de noter que ce fichier doit **Ãªtre prÃ©sent sur chaque environnement** afin de garantir une installation **dÃ©terministe**, et donc quâ€™il **doit Ãªtre versionnÃ©**.

Et les perfs dans tout ca ? Sur un benchmark sur le site de Yarn (donc probablement hyper objectif), les chiffres sont lÃ . Câ€™est *vachement* plus rapide dans la plupart des cas.

![](/media/yarn/bench.png)

![Benchmark NPM / YARN (source: [https://yarnpkg.com/en/compare](https://yarnpkg.com/en/compare))]( /media/yarn/bench2.png)*Benchmark NPM / YARN (source: [https://yarnpkg.com/en/compare](https://yarnpkg.com/en/compare))*

Et en rÃ©alitÃ© ?

Pour comparer les performance entre les deux outils, jâ€™ai utilisÃ© lâ€™utilitaire [npmvsyarn](https://www.npmjs.com/package/npmvsyarn) qui permet de comparer pour une librairie ou un projet (contenant un *package.json*) donnÃ©s les performances entre lâ€™utilisation de npm & celle de Yarn.

![Exemple avec les librairies Angular & React](/media/yarn/ex.png)*Exemple avec les librairies Angular & React*

Concernant lâ€™ajout/suppression dâ€™une librairie seule, Yarn est effectivement plus rapide (jusquâ€™Ã  50%), en particulier lorsque le cache et le fichier yarn.lock existe.

![](/media/yarn/ex2.png)

![Exemple avec un projet React ([redux-webpack-es6-boilerplate](https://github.com/nicksp/redux-webpack-es6-boilerplate)) et un projet Angular ([angular1.4-ES6-material-webpack-boilerplate](https://github.com/shprink/angular1.4-ES6-material-webpack-boilerplate))](/media/yarn/ex3.png)*Exemple avec un projet React ([redux-webpack-es6-boilerplate](https://github.com/nicksp/redux-webpack-es6-boilerplate)) et un projet Angular ([angular1.4-ES6-material-webpack-boilerplate](https://github.com/shprink/angular1.4-ES6-material-webpack-boilerplate))*

Sur un projet complet, Yarn sâ€™en sort mieux Ã©galement (jusquâ€™Ã  2.5 fois plus rapide). LÃ  encore, on voit que la prÃ©sence du cache et du *yarn.lock* amÃ©liore dâ€™autant plus les performances.

Bien Ã©videmment, ces exemples sont trop limitÃ©s pour Ãªtre reprÃ©sentatifs. NÃ©anmoins, le site *berriart.com* propose un benchmark plus complet des deux outils sur diffÃ©rents environnements dâ€™intÃ©gration continue.

[NPM vs Yarn benchmark](https://www.berriart.com/blog/2016/10/npm-yarn-benchmark/)

LÃ  encore, les rÃ©sultats vont dans le mÃªme sens:
> *Yarn est entre 2x et 3x plus rapide que npm*

## Conclusion

AprÃ¨s quelques heures dâ€™utilisation, Yarn semble rÃ©pondre aux attentes quâ€™il a suscitÃ©: plus rapide que npm, avec des fonctionnalitÃ©s Ã©quivalentes, et une migration sans heurts.

Bien quâ€™il soit sans doute peut-Ãªtre un peu tÃ´t pour lâ€™utiliser sur un projet structurant en production, il semble dÃ¨s aujourdâ€™hui Ãªtre une alternative crÃ©dible au client npm par dÃ©faut. On pourra donc facilement lâ€™utiliser sur un nouveau projet ou un projet annexe, afin de confirmer toutes les bonnes prÃ©dispositions affichÃ©es.

Quant au futur, on ne peut quâ€™espÃ©rer quâ€™il permette lâ€™amÃ©lioration de lâ€™existant, que se soit en poussant Ã  lâ€™amÃ©lioration de npm ou en devenant un standard defacto. A moins quâ€™un petit-nouveau nâ€™arrive dâ€™ici lÃ , et change encore la donneâ€¦
